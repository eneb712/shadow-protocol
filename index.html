<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Shadow Protocol - v2.2</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
        font-family: "Courier New", monospace;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #00ff88;
        overflow: hidden;
        touch-action: none;
        user-select: none;
      }

      #gameContainer {
        position: relative;
        background: #000;
        border: 3px solid #00ff88;
        box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        max-width: 100vw;
        max-height: 100vh;
        margin: auto;
      }

      canvas {
        display: block;
        image-rendering: pixelated;
        width: 100%;
        height: 100%;
      }

      /* --- UI Overlays --- */
      #menuScreen,
      #gameOverScreen,
      #victoryScreen,
      #pauseScreen,
      #levelCompleteScreen,
      #shopScreen,
      #levelSelectScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
      }

      /* HUD Buttons */
      #hudControls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 15;
        display: flex;
        gap: 10px;
      }

      .hud-btn {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #00ff88;
        color: #00ff88;
        padding: 8px 12px;
        font-family: "Courier New", monospace;
        font-weight: bold;
        cursor: pointer;
        text-transform: uppercase;
      }

      .hud-btn:hover {
        background: rgba(0, 255, 136, 0.2);
      }

      /* Typography */
      .screen-title {
        font-size: 48px;
        margin-bottom: 20px;
        text-shadow: 0 0 20px #00ff88;
        letter-spacing: 4px;
        text-align: center;
      }

      .screen-subtitle {
        font-size: 24px;
        margin-bottom: 20px;
        color: #66ffaa;
        text-align: center;
      }

      /* Buttons */
      .btn {
        background: linear-gradient(45deg, #00aa55, #00ff88);
        border: 2px solid #00ff88;
        color: #000;
        padding: 15px 40px;
        font-size: 20px;
        font-family: "Courier New", monospace;
        font-weight: bold;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 2px;
        min-width: 250px;
        text-align: center;
      }

      .btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
      }

      .btn.secondary {
        background: transparent;
        color: #00ff88;
        border: 2px solid #00ff88;
      }
      .btn.secondary:hover {
        background: rgba(0, 255, 136, 0.2);
      }

      .btn.disabled {
        background: #333;
        border-color: #555;
        color: #777;
        pointer-events: none;
        transform: none;
        box-shadow: none;
      }

      /* Level Select Grid */
      .level-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-bottom: 20px;
      }

      .level-btn {
        width: 80px;
        height: 80px;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0;
        min-width: unset;
      }

      /* Shop Grid */
      .shop-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-bottom: 20px;
        max-width: 800px;
        padding: 10px;
      }

      .shop-item {
        border: 1px solid #00ff88;
        padding: 15px;
        background: rgba(0, 50, 25, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .shop-item h4 {
        color: #fff;
        margin-bottom: 5px;
        font-size: 18px;
      }
      .shop-item p {
        color: #aaa;
        font-size: 12px;
        margin-bottom: 10px;
      }
      .shop-cost {
        color: #ffd700;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .currency-display {
        font-size: 24px;
        color: #ffd700;
        margin-bottom: 20px;
        border-bottom: 1px solid #ffd700;
        padding-bottom: 5px;
      }

      /* Instructions & Utilities */
      .instructions {
        width: 80%;
        max-width: 700px;
        text-align: left;
        margin: 20px;
        padding: 25px;
        background: rgba(0, 20, 10, 0.95);
        border: 1px solid #00ff88;
        border-radius: 5px;
        max-height: 70vh;
        overflow-y: auto;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 30;
      }

      .instructions h2 {
        text-align: center;
        margin-bottom: 20px;
        color: #fff;
        border-bottom: 1px solid #00ff88;
        padding-bottom: 10px;
      }
      .instructions h3 {
        color: #00ff88;
        margin-top: 20px;
        margin-bottom: 10px;
        font-size: 18px;
        text-transform: uppercase;
      }
      .instructions p {
        color: #ccc;
        line-height: 1.6;
        margin-bottom: 10px;
        font-size: 14px;
      }
      .instructions ul {
        margin-left: 20px;
        margin-bottom: 15px;
        color: #bbb;
      }
      .instructions li {
        margin-bottom: 5px;
      }
      .instructions strong {
        color: #fff;
      }

      .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        color: #ff3333;
        font-size: 24px;
        cursor: pointer;
        font-weight: bold;
        border: none;
        background: none;
      }

      .hidden {
        display: none !important;
      }

      /* Mobile Controls */
      #mobileControls {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 250px;
        pointer-events: none;
        z-index: 5;
        display: none; /* Hidden by default on desktop */
      }

      .control-button {
        position: absolute;
        background: rgba(0, 255, 136, 0.2);
        border: 2px solid rgba(0, 255, 136, 0.5);
        border-radius: 50%;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #00ff88;
        user-select: none;
      }

      #joystick {
        width: 120px;
        height: 120px;
        bottom: 30px;
        left: 30px;
      }
      #joystickKnob {
        width: 50px;
        height: 50px;
        background: rgba(0, 255, 136, 0.7);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #cloakButton {
        width: 90px;
        height: 90px;
        bottom: 40px;
        right: 30px;
        font-weight: bold;
      }

      /* Responsive */
      @media (max-width: 768px) {
        #gameContainer {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw !important;
          height: 100vh !important;
          border: none;
        }
        #mobileControls {
          display: block;
        }
        .screen-title {
          font-size: 32px;
        }
        .btn {
          padding: 12px 25px;
          font-size: 16px;
          margin: 8px;
          width: 80%;
        }
        .shop-container {
          grid-template-columns: 1fr;
          max-height: 50vh;
          overflow-y: auto;
        }
        .level-grid {
          gap: 10px;
        }
        .level-btn {
          width: 60px;
          height: 60px;
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div id="hudControls" class="hidden">
        <button class="hud-btn" onclick="game.togglePause()">II PAUSE</button>
      </div>

      <div id="mobileControls">
        <div id="joystick" class="control-button">
          <div id="joystickKnob"></div>
        </div>
        <div id="cloakButton" class="control-button">CLOAK</div>
      </div>

      <div id="menuScreen">
        <div class="screen-title">SHADOW PROTOCOL</div>
        <div class="screen-subtitle">Stealth Action Mission</div>
        <button class="btn" onclick="game.showLevelSelect()">
          START MISSION
        </button>
        <button class="btn" onclick="game.openShopFromMenu()">
          BLACK MARKET
        </button>
        <button class="btn secondary" onclick="game.toggleInstructions()">
          INSTRUCTIONS
        </button>

        <div id="instructionsPanel" class="instructions hidden">
          <button class="close-btn" onclick="game.toggleInstructions()">
            X
          </button>
          <h2>OPERATIVE MANUAL</h2>

          <h3>1. MISSION PROFILE</h3>
          <p>
            Welcome, Agent. You have been activated for the
            <strong>Shadow Protocol</strong>. Your objective is to infiltrate
            five high-security facilities, retrieve the classified
            <strong>Data Core</strong> hidden within each sector, and exfiltrate
            safely.
          </p>
          <p>
            Hostile forces will engage on sight. Stealth is your primary weapon.
            Direct confrontation is ill-advised.
          </p>

          <h3>2. CORE MECHANICS</h3>
          <ul>
            <li>
              <strong>Movement:</strong> Navigate the facility using WASD
              (Desktop) or the Virtual Joystick (Mobile).
            </li>
            <li>
              <strong>The Objective:</strong> Locate the cyan/gold
              <strong>Data Core</strong>. Once secured, the
              <strong>Extraction Point</strong> (dashed box) will activate.
              Reach it to complete the level.
            </li>
            <li>
              <strong>Currency:</strong> Collect gold <strong>Coins</strong>.
              Each coin is worth <strong>2 Credits</strong>. Use these to buy
              upgrades.
            </li>
          </ul>

          <h3>3. STEALTH & CLOAKING</h3>
          <p>
            Your suit is equipped with a limited-duration optical camouflage
            system.
          </p>
          <ul>
            <li>
              <strong>Activation:</strong> Hold SHIFT (Desktop) or the CLOAK
              button (Mobile).
            </li>
            <li>
              <strong>Effect:</strong> While active, you are invisible to
              cameras and guards. However, you move slower and consume
              <strong>Energy</strong> rapidly.
            </li>
            <li>
              <strong>Management:</strong> Watch your blue Energy bar. If it
              depletes, the cloak fails. Energy recharges slowly when not in
              use.
            </li>
          </ul>

          <h3>4. HOSTILES & HAZARDS</h3>
          <ul>
            <li>
              <strong>Guards:</strong> Patrol fixed routes. They have a vision
              cone. If you enter it while visible, they will enter ALERT state
              and open fire.
            </li>
            <li>
              <strong>Laser Grids:</strong> Red beams block corridors. They
              flicker on and off. Timing is key. Touching a laser triggers an
              alarm and deals damage.
            </li>
            <li>
              <strong>Health:</strong> If your Health (green bar) reaches zero,
              the mission is a failure.
            </li>
          </ul>

          <h3>5. THE BLACK MARKET</h3>
          <p>Between levels, you may access the encrypted shop network.</p>
          <ul>
            <li>
              <strong>Nano-Weave:</strong> Permanently increases maximum health.
            </li>
            <li>
              <strong>Battery Pack:</strong> Permanently increases maximum
              energy capacity.
            </li>
            <li>
              <strong>Servo Motors:</strong> Permanently increases movement
              speed.
            </li>
            <li>
              <strong>Medkit:</strong> Emergency repairs for your current
              health.
            </li>
          </ul>
          <p><em>Good luck, Agent. The shadows are your only ally.</em></p>
        </div>
      </div>

      <div id="levelSelectScreen" class="hidden">
        <div class="screen-title">SELECT SECTOR</div>
        <div class="level-grid" id="levelGrid"></div>
        <button class="btn secondary" onclick="game.returnToMenu()">
          BACK
        </button>
      </div>

      <div id="pauseScreen" class="hidden">
        <div class="screen-title">SYSTEM PAUSED</div>
        <button class="btn" onclick="game.togglePause()">RESUME</button>
        <button class="btn secondary" onclick="game.returnToMenu()">
          MAIN MENU
        </button>
      </div>

      <div id="levelCompleteScreen" class="hidden">
        <div class="screen-title">LEVEL CLEAR</div>
        <div class="screen-subtitle" id="levelScoreDisplay"></div>
        <button class="btn" onclick="game.openShop()">BLACK MARKET</button>
        <button class="btn" onclick="game.nextLevelAction()">NEXT LEVEL</button>
        <button class="btn secondary" onclick="game.returnToMenu()">
          MAIN MENU
        </button>
      </div>

      <div id="shopScreen" class="hidden">
        <div class="screen-title">BLACK MARKET</div>
        <div class="currency-display" id="shopCurrency">COINS: 0</div>

        <div class="shop-container">
          <div class="shop-item">
            <h4>NANO-WEAVE</h4>
            <p>Increases Max Health (+20)</p>
            <div class="shop-cost">50 COINS</div>
            <button class="hud-btn" onclick="game.buyUpgrade('health')">
              BUY
            </button>
          </div>
          <div class="shop-item">
            <h4>BATTERY PACK</h4>
            <p>Increases Max Energy (+20)</p>
            <div class="shop-cost">50 COINS</div>
            <button class="hud-btn" onclick="game.buyUpgrade('energy')">
              BUY
            </button>
          </div>
          <div class="shop-item">
            <h4>MEDKIT</h4>
            <p>Restore Full Health</p>
            <div class="shop-cost">30 COINS</div>
            <button class="hud-btn" onclick="game.buyUpgrade('heal')">
              BUY
            </button>
          </div>
          <div class="shop-item">
            <h4>SERVO MOTORS</h4>
            <p>Increase Move Speed (+5%)</p>
            <div class="shop-cost">80 COINS</div>
            <button class="hud-btn" onclick="game.buyUpgrade('speed')">
              BUY
            </button>
          </div>
        </div>
        <button class="btn secondary" onclick="game.closeShop()">RETURN</button>
      </div>

      <div id="gameOverScreen" class="hidden">
        <div class="screen-title">MISSION FAILED</div>
        <div class="screen-subtitle">Agent Down</div>
        <div id="finalScore"></div>
        <button class="btn" onclick="game.retryLevel()">RETRY SECTOR</button>
        <button class="btn secondary" onclick="game.returnToMenu()">
          MAIN MENU
        </button>
      </div>

      <div id="victoryScreen" class="hidden">
        <div class="screen-title">MISSION ACCOMPLISHED</div>
        <div class="screen-subtitle">All Data Retrieved</div>
        <div id="victoryScore"></div>
        <button class="btn" onclick="game.returnToMenu()">MAIN MENU</button>
      </div>
    </div>

    <script>
      // ==================== GAME CONFIGURATION ====================
      let CONFIG = {
        canvas: { width: 800, height: 600 },
        player: {
          baseSpeed: 3,
          speedMultiplier: 1,
          size: 20,
          maxHealth: 100,
          maxEnergy: 100,
          energyDrainRate: 0.5,
          energyRegenRate: 0.3,
          cloakOpacity: 0.3,
        },
        enemy: {
          size: 20,
          speed: 2,
          chaseSpeed: 3.5,
          visionRange: 150,
          visionAngle: 60,
          detectionTime: 30,
          patrolPauseTime: 60,
        },
        laser: { onDuration: 120, offDuration: 90, damage: 10 },
        score: { stealthBonus: 2, detectionPenalty: 50 },
      };

      // ==================== SOUND SYSTEM ====================
      class SoundSystem {
        constructor() {
          this.audioContext = null;
          this.initialized = false;
        }

        init() {
          if (this.initialized) return;
          try {
            this.audioContext = new (
              window.AudioContext || window.webkitAudioContext
            )();
            this.sfxGain = this.audioContext.createGain();
            this.sfxGain.gain.value = 0.3;
            this.sfxGain.connect(this.audioContext.destination);
            this.initialized = true;
          } catch (e) {
            console.warn("Audio not supported", e);
          }
        }

        playTone(freq, type, duration, vol = 0.2) {
          if (!this.initialized) return;
          const ctx = this.audioContext;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, ctx.currentTime);
          gain.gain.setValueAtTime(vol, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            ctx.currentTime + duration,
          );
          osc.connect(gain);
          gain.connect(this.sfxGain);
          osc.start();
          osc.stop(ctx.currentTime + duration);
        }

        playCoin() {
          this.playTone(1200, "sine", 0.1);
          setTimeout(() => this.playTone(1800, "sine", 0.2), 50);
        }
        playPickup() {
          this.playTone(600, "sine", 0.1);
          setTimeout(() => this.playTone(800, "sine", 0.2), 100);
        }
        playAlert() {
          this.playTone(150, "sawtooth", 0.3);
        }
        playDamage() {
          this.playTone(100, "square", 0.2);
        }
        playLaserHit() {
          this.playTone(500, "sawtooth", 0.1);
        }
      }

      // ==================== INPUT HANDLER ====================
      class InputHandler {
        constructor() {
          this.keys = {};
          this.mobileInput = { dx: 0, dy: 0, cloaking: false };
          this.isMobile =
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
              navigator.userAgent,
            );
          this.setupEventListeners();
          if (this.isMobile) this.setupMobileControls();
        }

        setupEventListeners() {
          window.addEventListener("keydown", (e) => {
            this.keys[e.key.toLowerCase()] = true;
            if (e.key === "p" || e.key === "P" || e.key === "Escape") {
              if (game.state === "playing" || game.state === "paused")
                game.togglePause();
            }
          });
          window.addEventListener(
            "keyup",
            (e) => (this.keys[e.key.toLowerCase()] = false),
          );
        }

        setupMobileControls() {
          const joystick = document.getElementById("joystick");
          const joystickKnob = document.getElementById("joystickKnob");
          const cloakButton = document.getElementById("cloakButton");
          let joystickActive = false;
          let joystickCenter = { x: 0, y: 0 };
          const maxDistance = 35;

          joystick.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              joystickActive = true;
              const rect = joystick.getBoundingClientRect();
              joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
              };
            },
            { passive: false },
          );

          joystick.addEventListener(
            "touchmove",
            (e) => {
              if (!joystickActive) return;
              e.preventDefault();
              const touch = e.touches[0];
              let dx = touch.clientX - joystickCenter.x;
              let dy = touch.clientY - joystickCenter.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > maxDistance) {
                dx = (dx / dist) * maxDistance;
                dy = (dy / dist) * maxDistance;
              }
              joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
              this.mobileInput.dx = dx / maxDistance;
              this.mobileInput.dy = dy / maxDistance;
            },
            { passive: false },
          );

          const resetJoystick = (e) => {
            if (e) e.preventDefault();
            joystickActive = false;
            joystickKnob.style.transform = "translate(-50%, -50%)";
            this.mobileInput.dx = 0;
            this.mobileInput.dy = 0;
          };
          joystick.addEventListener("touchend", resetJoystick);
          joystick.addEventListener("touchcancel", resetJoystick);

          cloakButton.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.mobileInput.cloaking = true;
          });
          cloakButton.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.mobileInput.cloaking = false;
          });
        }

        isMoving() {
          if (this.isMobile)
            return (
              Math.abs(this.mobileInput.dx) > 0.1 ||
              Math.abs(this.mobileInput.dy) > 0.1
            );
          return (
            this.keys["w"] ||
            this.keys["a"] ||
            this.keys["s"] ||
            this.keys["d"] ||
            this.keys["arrowup"] ||
            this.keys["arrowdown"] ||
            this.keys["arrowleft"] ||
            this.keys["arrowright"]
          );
        }

        getMovementVector() {
          if (this.isMobile)
            return { dx: this.mobileInput.dx, dy: this.mobileInput.dy };
          let dx = 0,
            dy = 0;
          if (this.keys["w"] || this.keys["arrowup"]) dy -= 1;
          if (this.keys["s"] || this.keys["arrowdown"]) dy += 1;
          if (this.keys["a"] || this.keys["arrowleft"]) dx -= 1;
          if (this.keys["d"] || this.keys["arrowright"]) dx += 1;
          if (dx !== 0 && dy !== 0) {
            const len = Math.sqrt(dx * dx + dy * dy);
            dx /= len;
            dy /= len;
          }
          return { dx, dy };
        }
      }

      // ==================== ENTITIES ====================
      class Coin {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = 12;
          this.collected = false;
          this.rotation = Math.random() * Math.PI;
        }
        draw(ctx) {
          if (this.collected) return;
          this.rotation += 0.05;
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = "#FFD700";
          ctx.beginPath();
          ctx.ellipse(
            0,
            0,
            (this.size / 2) * Math.abs(Math.cos(this.rotation)),
            this.size / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.restore();
        }
      }

      class Player {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = CONFIG.player.size;
          this.speed = CONFIG.player.baseSpeed * CONFIG.player.speedMultiplier;
          this.maxHealth = CONFIG.player.maxHealth;
          this.health = this.maxHealth;
          this.maxEnergy = CONFIG.player.maxEnergy;
          this.energy = this.maxEnergy;
          this.isCloaked = false;
          this.hasDataCore = false;
          this.damageCooldown = 0;
        }
        update(input) {
          const isCloakPressed = input.isMobile
            ? input.mobileInput.cloaking
            : input.keys["shift"];
          if (isCloakPressed && this.energy > 0) {
            this.isCloaked = true;
            this.energy -= CONFIG.player.energyDrainRate;
            if (this.energy < 0) this.energy = 0;
          } else {
            this.isCloaked = false;
            if (this.energy < this.maxEnergy)
              this.energy += CONFIG.player.energyRegenRate;
          }
          const { dx, dy } = input.getMovementVector();
          let moveSpeed = this.speed;
          if (this.isCloaked) moveSpeed *= 0.8;
          const newX = this.x + dx * moveSpeed;
          const newY = this.y + dy * moveSpeed;
          if (newX > 10 && newX < CONFIG.canvas.width - 10) this.x = newX;
          if (newY > 10 && newY < CONFIG.canvas.height - 10) this.y = newY;
          if (this.damageCooldown > 0) this.damageCooldown--;
        }
        takeDamage(amt, sfx) {
          if (this.damageCooldown > 0) return;
          this.health -= amt;
          this.damageCooldown = 45;
          sfx.playDamage();
        }
        draw(ctx) {
          ctx.save();
          if (this.isCloaked) ctx.globalAlpha = CONFIG.player.cloakOpacity;
          ctx.fillStyle = this.hasDataCore ? "#ffaa00" : "#00ff88";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
          if (
            this.damageCooldown > 0 &&
            Math.floor(Date.now() / 50) % 2 === 0
          ) {
            ctx.fillStyle = "red";
            ctx.fill();
          }
          ctx.restore();
        }
      }

      class Enemy {
        constructor(x, y, path) {
          this.x = x;
          this.y = y;
          this.path = path;
          this.pathIndex = 0;
          this.speed = CONFIG.enemy.speed;
          this.angle = 0;
          this.state = "patrol";
          this.visionRange = CONFIG.enemy.visionRange;
          this.pauseTimer = 0;
        }
        update(player, sfx) {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const distToPlayer = Math.sqrt(dx * dx + dy * dy);
          let seen = false;
          if (!player.isCloaked && distToPlayer < this.visionRange) {
            const angleToPlayer = Math.atan2(dy, dx);
            let angleDiff = angleToPlayer - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            if (
              Math.abs(angleDiff) <
              (CONFIG.enemy.visionAngle * Math.PI) / 180 / 2
            )
              seen = true;
          }
          if (seen) {
            if (this.state !== "chase") sfx.playAlert();
            this.state = "chase";
            this.angle = Math.atan2(dy, dx);
            this.x += Math.cos(this.angle) * CONFIG.enemy.chaseSpeed;
            this.y += Math.sin(this.angle) * CONFIG.enemy.chaseSpeed;
            if (distToPlayer < 20) player.takeDamage(10, sfx);
          } else {
            this.state = "patrol";
            if (this.pauseTimer > 0) {
              this.pauseTimer--;
              return;
            }
            const target = this.path[this.pathIndex];
            const tDx = target.x - this.x;
            const tDy = target.y - this.y;
            if (Math.sqrt(tDx * tDx + tDy * tDy) < 5) {
              this.pathIndex = (this.pathIndex + 1) % this.path.length;
              this.pauseTimer = CONFIG.enemy.patrolPauseTime;
            } else {
              this.angle = Math.atan2(tDy, tDx);
              this.x += Math.cos(this.angle) * this.speed;
              this.y += Math.sin(this.angle) * this.speed;
            }
          }
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.fillStyle =
            this.state === "chase"
              ? "rgba(255,0,0,0.3)"
              : "rgba(255,200,0,0.2)";
          ctx.beginPath();
          ctx.moveTo(0, 0);
          const halfAngle = (CONFIG.enemy.visionAngle * Math.PI) / 180 / 2;
          ctx.arc(0, 0, this.visionRange, -halfAngle, halfAngle);
          ctx.fill();
          ctx.fillStyle = this.state === "chase" ? "#f00" : "#f80";
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      class LaserGrid {
        constructor(x, y, length, isVertical, speedStr = "normal") {
          this.x = x;
          this.y = y;
          this.length = length;
          this.isVertical = isVertical;
          this.active = true;
          this.timer = 0;
          this.onTime = speedStr === "fast" ? 60 : 120;
          this.offTime = speedStr === "fast" ? 40 : 90;
        }
        update() {
          this.timer++;
          if (this.active && this.timer > this.onTime) {
            this.active = false;
            this.timer = 0;
          } else if (!this.active && this.timer > this.offTime) {
            this.active = true;
            this.timer = 0;
          }
        }
        checkCollision(player, sfx) {
          if (!this.active) return;
          const margin = 5;
          let hit = false;
          if (this.isVertical) {
            if (
              player.x > this.x - margin &&
              player.x < this.x + margin &&
              player.y > this.y &&
              player.y < this.y + this.length
            )
              hit = true;
          } else {
            if (
              player.y > this.y - margin &&
              player.y < this.y + margin &&
              player.x > this.x &&
              player.x < this.x + this.length
            )
              hit = true;
          }
          if (hit) player.takeDamage(CONFIG.laser.damage, sfx);
        }
        draw(ctx) {
          if (!this.active) {
            ctx.strokeStyle = "rgba(255,0,0,0.1)";
            ctx.setLineDash([5, 5]);
          } else {
            ctx.strokeStyle = "#f00";
            ctx.setLineDash([]);
            ctx.shadowBlur = 10;
            ctx.shadowColor = "red";
          }
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          if (this.isVertical) ctx.lineTo(this.x, this.y + this.length);
          else ctx.lineTo(this.x + this.length, this.y);
          ctx.stroke();
          ctx.shadowBlur = 0;
          ctx.setLineDash([]);
        }
      }

      // ==================== MAIN GAME STATE ====================
      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.state = "menu";
          this.level = 1;
          this.maxLevels = 5;
          this.maxUnlockedLevel = 1;
          this.score = 0;
          this.totalCoins = 0;
          this.collectedCoinsLevel = 0;
          this.shopReturnState = "menu"; // Tracks where to go back to after shop

          this.player = null;
          this.enemies = [];
          this.lasers = [];
          this.coins = [];
          this.dataCore = null;
          this.extraction = null;

          this.input = new InputHandler();
          this.audio = new SoundSystem();

          this.resize();
          window.addEventListener("resize", () => this.resize());

          this.loop = this.loop.bind(this);
          requestAnimationFrame(this.loop);
        }

        resize() {
          const isMobile = /Android|webOS|iPhone|iPod|BlackBerry/i.test(
            navigator.userAgent,
          );
          if (isMobile) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            CONFIG.canvas.width = window.innerWidth;
            CONFIG.canvas.height = window.innerHeight;
          }
        }

        showLevelSelect() {
          document.getElementById("menuScreen").classList.add("hidden");
          document
            .getElementById("levelSelectScreen")
            .classList.remove("hidden");

          const grid = document.getElementById("levelGrid");
          grid.innerHTML = "";

          for (let i = 1; i <= this.maxLevels; i++) {
            const btn = document.createElement("button");
            btn.className = `btn level-btn ${i > this.maxUnlockedLevel ? "disabled" : ""}`;
            btn.innerText = i;
            if (i <= this.maxUnlockedLevel) {
              btn.onclick = () => this.startSpecificLevel(i);
            }
            grid.appendChild(btn);
          }
        }

        startSpecificLevel(lvl) {
          this.level = lvl;
          this.collectedCoinsLevel = 0;
          if (lvl === 1) {
            this.score = 0;
            // Note: We do NOT reset totalCoins here so players can carry them over
          }
          document.getElementById("hudControls").classList.remove("hidden");
          this.loadLevel(this.level);
        }

        togglePause() {
          if (this.state === "playing") {
            this.state = "paused";
            document.getElementById("pauseScreen").classList.remove("hidden");
          } else if (this.state === "paused") {
            this.state = "playing";
            document.getElementById("pauseScreen").classList.add("hidden");
          }
        }

        // Logic to open Shop from Main Menu
        openShopFromMenu() {
          this.shopReturnState = "menu";
          document.getElementById("menuScreen").classList.add("hidden");
          document.getElementById("shopScreen").classList.remove("hidden");
          this.updateShopUI();
        }

        // Logic to open Shop from Level Complete
        openShop() {
          this.shopReturnState = "levelComplete";
          document
            .getElementById("levelCompleteScreen")
            .classList.add("hidden");
          document.getElementById("shopScreen").classList.remove("hidden");
          this.updateShopUI();
        }

        closeShop() {
          document.getElementById("shopScreen").classList.add("hidden");
          if (this.shopReturnState === "menu") {
            document.getElementById("menuScreen").classList.remove("hidden");
          } else {
            document
              .getElementById("levelCompleteScreen")
              .classList.remove("hidden");
          }
        }

        updateShopUI() {
          document.getElementById("shopCurrency").innerText =
            `COINS: ${this.totalCoins}`;
        }

        buyUpgrade(type) {
          let cost = 0;
          let success = false;
          if (type === "health") {
            cost = 50;
            if (this.totalCoins >= cost) {
              CONFIG.player.maxHealth += 20;
              success = true;
            }
          } else if (type === "energy") {
            cost = 50;
            if (this.totalCoins >= cost) {
              CONFIG.player.maxEnergy += 20;
              success = true;
            }
          } else if (type === "speed") {
            cost = 80;
            if (this.totalCoins >= cost) {
              CONFIG.player.speedMultiplier += 0.05;
              success = true;
            }
          } else if (type === "heal") {
            cost = 30;
            if (this.totalCoins >= cost) {
              if (this.player) this.player.health = this.player.maxHealth;
              success = true;
            }
          }

          if (success) {
            this.totalCoins -= cost;
            this.updateShopUI();
            this.audio.playPickup();
          }
        }

        loadLevel(lvl) {
          this.audio.init();
          this.state = "playing";

          [
            "menuScreen",
            "gameOverScreen",
            "victoryScreen",
            "pauseScreen",
            "levelCompleteScreen",
            "shopScreen",
            "levelSelectScreen",
          ].forEach((id) =>
            document.getElementById(id).classList.add("hidden"),
          );

          this.collectedCoinsLevel = 0;
          let healthPct = 1;
          if (this.player)
            healthPct = this.player.health / this.player.maxHealth;

          this.player = new Player(50, 50);
          this.player.health = this.player.maxHealth * healthPct;
          if (this.player.health < 20) this.player.health = 20;

          this.enemies = [];
          this.lasers = [];
          this.coins = [];
          this.dataCore = { x: 0, y: 0, collected: false };
          this.extraction = { x: 0, y: 0, w: 60, h: 60 };

          const W = CONFIG.canvas.width;
          const H = CONFIG.canvas.height;

          if (lvl === 1) {
            this.dataCore = { x: W - 100, y: H - 100, collected: false };
            this.extraction = { x: 50, y: H - 100, w: 50, h: 50 };
            this.enemies.push(
              new Enemy(300, 200, [
                { x: 300, y: 200 },
                { x: 500, y: 200 },
              ]),
            );
            this.enemies.push(
              new Enemy(400, 400, [
                { x: 400, y: 400 },
                { x: 200, y: 400 },
              ]),
            );
            this.lasers.push(new LaserGrid(W / 2, 0, H, true));
            this.spawnCoins(3);
          } else if (lvl === 2) {
            this.dataCore = { x: W - 50, y: 50, collected: false };
            this.extraction = { x: W - 50, y: H - 50, w: 50, h: 50 };
            this.enemies.push(
              new Enemy(150, 150, [
                { x: 150, y: 150 },
                { x: 150, y: 400 },
              ]),
            );
            this.enemies.push(
              new Enemy(350, 400, [
                { x: 350, y: 400 },
                { x: 350, y: 100 },
              ]),
            );
            this.enemies.push(
              new Enemy(600, 200, [
                { x: 600, y: 200 },
                { x: 750, y: 200 },
                { x: 750, y: 500 },
              ]),
            );
            this.lasers.push(new LaserGrid(250, 100, 300, false));
            this.lasers.push(new LaserGrid(500, 300, 300, false));
            this.spawnCoins(5);
          } else if (lvl === 3) {
            this.dataCore = { x: W / 2, y: H / 2, collected: false };
            this.extraction = { x: 50, y: 50, w: 50, h: 50 };
            this.enemies.push(
              new Enemy(200, 200, [
                { x: 200, y: 200 },
                { x: 600, y: 200 },
                { x: 600, y: 400 },
                { x: 200, y: 400 },
              ]),
            );
            this.enemies.push(
              new Enemy(600, 400, [
                { x: 600, y: 400 },
                { x: 200, y: 400 },
                { x: 200, y: 200 },
                { x: 600, y: 200 },
              ]),
            );
            this.lasers.push(new LaserGrid(100, 100, H - 200, true, "fast"));
            this.lasers.push(
              new LaserGrid(W - 100, 100, H - 200, true, "fast"),
            );
            this.spawnCoins(6);
          } else if (lvl === 4) {
            this.dataCore = { x: W - 80, y: H - 80, collected: false };
            this.extraction = { x: 50, y: H - 50, w: 50, h: 50 };
            for (let i = 0; i < 4; i++) {
              this.enemies.push(
                new Enemy(200 + i * 150, 100 + i * 50, [
                  { x: 200 + i * 150, y: 100 },
                  { x: 200 + i * 150, y: 500 },
                ]),
              );
            }
            this.lasers.push(new LaserGrid(0, 300, W, false, "fast"));
            this.spawnCoins(8);
          } else if (lvl === 5) {
            this.dataCore = { x: W - 50, y: 50, collected: false };
            this.extraction = { x: 50, y: 50, w: 50, h: 50 };
            this.enemies.push(
              new Enemy(100, 300, [
                { x: 100, y: 300 },
                { x: W - 100, y: 300 },
              ]),
            );
            this.enemies.push(
              new Enemy(W - 100, 200, [
                { x: W - 100, y: 200 },
                { x: 100, y: 200 },
              ]),
            );
            this.enemies.push(
              new Enemy(100, 400, [
                { x: 100, y: 400 },
                { x: W - 100, y: 400 },
              ]),
            );
            this.lasers.push(new LaserGrid(W / 2, 0, H, true, "fast"));
            this.lasers.push(new LaserGrid(0, H / 2, W, false, "fast"));
            this.spawnCoins(10);
          }
        }

        spawnCoins(count) {
          for (let i = 0; i < count; i++) {
            const cx = 50 + Math.random() * (CONFIG.canvas.width - 100);
            const cy = 50 + Math.random() * (CONFIG.canvas.height - 100);
            this.coins.push(new Coin(cx, cy));
          }
        }

        completeLevel() {
          this.state = "menu";
          this.totalCoins += this.collectedCoinsLevel;
          // Unlock next level
          if (this.level < this.maxLevels) {
            if (this.level + 1 > this.maxUnlockedLevel) {
              this.maxUnlockedLevel = this.level + 1;
            }
          }

          document.getElementById("levelScoreDisplay").innerText =
            `Level ${this.level} Complete!\nCoins Collected: ${this.collectedCoinsLevel}`;

          if (this.level >= this.maxLevels) {
            document.getElementById("victoryScreen").classList.remove("hidden");
            document.getElementById("victoryScore").innerText =
              `Final Score: ${this.score}\nTotal Coins: ${this.totalCoins}`;
          } else {
            document
              .getElementById("levelCompleteScreen")
              .classList.remove("hidden");
          }
        }

        nextLevelAction() {
          this.level++;
          this.loadLevel(this.level);
        }

        retryLevel() {
          // Restart current level
          this.loadLevel(this.level);
        }

        returnToMenu() {
          this.state = "menu";
          [
            "menuScreen",
            "gameOverScreen",
            "victoryScreen",
            "pauseScreen",
            "levelCompleteScreen",
            "shopScreen",
            "levelSelectScreen",
          ].forEach((id) =>
            document.getElementById(id).classList.add("hidden"),
          );
          document.getElementById("menuScreen").classList.remove("hidden");
          document.getElementById("hudControls").classList.add("hidden");
        }

        toggleInstructions() {
          document
            .getElementById("instructionsPanel")
            .classList.toggle("hidden");
        }

        loop() {
          if (this.state === "playing") {
            this.update();
            this.draw();
          } else if (this.state === "paused") {
            this.draw();
          }
          requestAnimationFrame(this.loop);
        }

        update() {
          this.player.update(this.input);
          this.enemies.forEach((e) => e.update(this.player, this.audio));
          this.lasers.forEach((l) => {
            l.update();
            l.checkCollision(this.player, this.audio);
          });

          this.coins.forEach((c) => {
            if (
              !c.collected &&
              Math.hypot(this.player.x - c.x, this.player.y - c.y) <
                this.player.size + c.size
            ) {
              c.collected = true;
              this.collectedCoinsLevel += 2; // INFLATION: 1 Coin = 2 Value
              this.score += 50;
              this.audio.playCoin();
            }
          });

          if (
            !this.dataCore.collected &&
            Math.hypot(
              this.player.x - this.dataCore.x,
              this.player.y - this.dataCore.y,
            ) < 30
          ) {
            this.dataCore.collected = true;
            this.player.hasDataCore = true;
            this.score += 500;
            this.audio.playPickup();
          }

          if (this.player.hasDataCore) {
            const ex = this.extraction;
            if (
              this.player.x > ex.x &&
              this.player.x < ex.x + ex.w &&
              this.player.y > ex.y &&
              this.player.y < ex.y + ex.h
            ) {
              this.completeLevel();
            }
          }

          if (this.player.health <= 0) {
            this.state = "gameover";
            document
              .getElementById("gameOverScreen")
              .classList.remove("hidden");
            document.getElementById("finalScore").innerText =
              `Score: ${this.score}`;
            this.audio.playDamage();
          }
        }

        draw() {
          this.ctx.fillStyle = "#111";
          this.ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
          this.ctx.strokeStyle = "rgba(0, 255, 136, 0.1)";
          this.ctx.lineWidth = 1;
          for (let i = 0; i < CONFIG.canvas.width; i += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(i, 0);
            this.ctx.lineTo(i, CONFIG.canvas.height);
            this.ctx.stroke();
          }
          for (let i = 0; i < CONFIG.canvas.height; i += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, i);
            this.ctx.lineTo(CONFIG.canvas.width, i);
            this.ctx.stroke();
          }

          const ex = this.extraction;
          this.ctx.strokeStyle = this.player.hasDataCore ? "#0f8" : "#555";
          this.ctx.setLineDash([5, 5]);
          this.ctx.lineWidth = 3;
          this.ctx.strokeRect(ex.x, ex.y, ex.w, ex.h);
          this.ctx.fillStyle = this.player.hasDataCore ? "#0f8" : "#555";
          this.ctx.font = "10px Courier New";
          this.ctx.fillText("EXTRACT", ex.x + 5, ex.y + ex.h / 2);
          this.ctx.setLineDash([]);

          if (!this.dataCore.collected) {
            this.ctx.save();
            this.ctx.translate(this.dataCore.x, this.dataCore.y);
            this.ctx.rotate(Date.now() / 500);
            this.ctx.fillStyle = "#0ff";
            this.ctx.fillRect(-10, -10, 20, 20);
            this.ctx.restore();
          }

          this.coins.forEach((c) => c.draw(this.ctx));
          this.lasers.forEach((l) => l.draw(this.ctx));
          this.enemies.forEach((e) => e.draw(this.ctx));
          this.player.draw(this.ctx);
          this.drawHUD();
        }

        drawHUD() {
          const ctx = this.ctx;
          const p = this.player;
          ctx.fillStyle = "#fff";
          ctx.font = "20px Courier New";
          ctx.textAlign = "left";
          ctx.fillText(`SCORE: ${this.score}`, 20, 30);
          ctx.fillText(`LEVEL: ${this.level}/5`, 20, 55);
          ctx.fillStyle = "#ffd700";
          ctx.fillText(
            `COINS: ${this.totalCoins + this.collectedCoinsLevel}`,
            20,
            80,
          );

          const barW = 200;
          ctx.fillStyle = "#333";
          ctx.fillRect(20, CONFIG.canvas.height - 60, barW, 15);
          ctx.fillStyle = p.health > 30 ? "#0f8" : "#f00";
          ctx.fillRect(
            20,
            CONFIG.canvas.height - 60,
            barW * (p.health / p.maxHealth),
            15,
          );
          ctx.strokeStyle = "#fff";
          ctx.strokeRect(20, CONFIG.canvas.height - 60, barW, 15);
          ctx.fillStyle = "#fff";
          ctx.font = "12px Courier New";
          ctx.fillText("HEALTH", 20, CONFIG.canvas.height - 65);

          ctx.fillStyle = "#333";
          ctx.fillRect(20, CONFIG.canvas.height - 30, barW, 15);
          ctx.fillStyle = "#0ae";
          ctx.fillRect(
            20,
            CONFIG.canvas.height - 30,
            barW * (p.energy / p.maxEnergy),
            15,
          );
          ctx.strokeRect(20, CONFIG.canvas.height - 30, barW, 15);
          ctx.fillStyle = "#fff";
          ctx.fillText("ENERGY", 20, CONFIG.canvas.height - 35);

          if (p.isCloaked) {
            ctx.fillStyle = "#0ae";
            ctx.font = "bold 20px Courier New";
            ctx.textAlign = "center";
            ctx.fillText("CLOAK ACTIVE", CONFIG.canvas.width / 2, 40);
          }
        }
      }

      const game = new Game();
    </script>
  </body>
</html>
